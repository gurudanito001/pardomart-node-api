// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // or mysql, sqlite, etc. based on your actual database
  url      = env("DATABASE_URL")
}

model Verification {
  mobileNumber String    @id
  code         String
  expiresAt    DateTime
  createdAt    DateTime? @default(now())
  attempts     Int?      @default(0)
}

model User {
  id               String  @id @default(uuid())
  name             String
  email            String
  mobileNumber     String
  mobileVerified   Boolean @default(false)
  dynamicMediaUrls Json?
  active           Boolean @default(true)
  language         String?
  notification     Json?
  rememberToken    String?
  referralCode     String?
  role             Role
  // NEW: Link Vendor Staff to their Vendor
  vendorId         String? // ID of the Vendor this staff user belongs to (null for customers/delivery_persons)
  vendor           Vendor? @relation("VendorStaff", fields: [vendorId], references: [id], onDelete: SetNull)

  vendors           Vendor[]          @relation("Vendor")
  supportMessages   Support[]         @relation("SupportMessages")
  orderShoppers     Order[]           @relation("OrderShopper")
  orderDeliverers   Order[]           @relation("OrderDeliverer")
  deliveryAddresses DeliveryAddress[]
  orders            Order[]           @relation("OrderCustomer")
  carts             Cart[]
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // New fields for ratings
  ratingsGiven    Rating[] @relation("RatingsGiven")
  ratingsReceived Rating[] @relation("RatingsReceived")
  wishlistItems   WishlistItem[] 
  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")
  notifications   Notification[]
  devices         Device[]

  @@unique([mobileNumber, role])
}

model Product {
  id              String          @id @default(uuid())
  barcode         String          @unique
  name            String
  description     String?
  images          String[]
  weight          Float?
  weightUnit      String?
  attributes      Json?
  meta            Json?
  vendorProducts  VendorProduct[] @relation("baseProduct")
  categoryIds     String[]
  categories      Category[]
  isAlcohol       Boolean         @default(false)
  isAgeRestricted Boolean         @default(false)
  tags            Tag[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

model VendorProduct {
  id              String      @id @default(uuid())
  vendor          Vendor      @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  vendorId        String
  product         Product     @relation("baseProduct", fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  price           Float
  name            String
  description     String?
  discountedPrice Float?
  images          String[]
  weight          Float?
  weightUnit      String?
  stock           Int?
  isAvailable     Boolean     @default(true)
  isAlcohol       Boolean     @default(false)
  isAgeRestricted Boolean     @default(false)
  attributes      Json?
  categoryIds     String[]
  categories      Category[]
  tags            Tag[]
  cartItems       CartItem[]
  orderItems      OrderItem[] @relation("originalProduct")
  replacementFor  OrderItem[] @relation("replacementFor")
  wishlistItems   WishlistItem[]
  chosenAsReplacementFor OrderItem[] @relation("chosenReplacement")
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@unique([vendorId, productId])
}

model Cart {
  id        String     @id @default(uuid())
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  vendor    Vendor     @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  vendorId  String
  items     CartItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@unique([userId, vendorId]) // Ensure one cart per user-vendor pair
}

model CartItem {
  id              String        @id @default(uuid())
  cartId          String
  cart            Cart          @relation(fields: [cartId], references: [id], onDelete: Cascade)
  vendorProductId String
  vendorProduct   VendorProduct @relation(fields: [vendorProductId], references: [id])
  quantity        Int
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@unique([cartId, vendorProductId])
}

model OrderItem {
  id              String        @id @default(uuid())
  orderId         String
  order           Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  vendorProductId String
  vendorProduct   VendorProduct @relation("originalProduct", fields: [vendorProductId], references: [id])
  quantity        Int
  instructions    String?
  replacements    VendorProduct[] @relation("replacementFor")

  // Fields for live shopping
  status                OrderItemStatus @default(PENDING)
  quantityFound         Int?
  chosenReplacementId   String?
  chosenReplacement     VendorProduct?  @relation("chosenReplacement", fields: [chosenReplacementId], references: [id], onDelete: SetNull)
  isReplacementApproved Boolean?

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

model DeliveryPersonLocation {
  id        String   @id @default(cuid())
  latitude  Float
  longitude Float
  createdAt DateTime @default(now())

  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, createdAt])
}

model Device {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  fcmToken  String   @unique // A token should be unique across all devices
  platform  String   // e.g., "ios", "android", "web"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  body      String
  isRead    Boolean          @default(false)
  meta      Json? // To store related IDs like orderId, etc. for deep linking
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@index([userId, isRead, createdAt])
}

model Order {
  id                         String           @id @default(uuid())
  userId                     String
  user                       User             @relation("OrderCustomer", fields: [userId], references: [id], onDelete: Cascade)
  vendorId                   String
  vendor                     Vendor           @relation(fields: [vendorId], references: [id])
  totalAmount                Float
  deliveryFee                Float?
  serviceFee                 Float?
  shoppingFee                Float?
  shopperTip                 Float? 
  deliveryPersonTip          Float?
  paymentMethod              PaymentMethods   @default(credit_card)
  paymentStatus              PaymentStatus    @default(pending)
  orderStatus                OrderStatus      @default(pending)
  reasonForDecline           String?
  deliveryAddressId          String?
  deliveryAddress            DeliveryAddress? @relation(fields: [deliveryAddressId], references: [id])
  deliveryInstructions       String?
  shopperId                  String?
  shopper                    User?            @relation("OrderShopper", fields: [shopperId], references: [id])
  deliveryPersonId           String?
  deliveryPerson             User?            @relation("OrderDeliverer", fields: [deliveryPersonId], references: [id])
  shoppingMethod             ShoppingMethod?  @default(vendor)
  deliveryMethod             DeliveryMethod?  @default(customer_pickup)
  shoppingStartTime          DateTime?
  scheduledDeliveryTime      DateTime?
  actualDeliveryTime         DateTime?
  orderItems                 OrderItem[]
  createdAt                  DateTime         @default(now())
  updatedAt                  DateTime         @updatedAt
  ratings Rating[]
  deliveryPersonLocations DeliveryPersonLocation[]
  messages                   Message[]
}

model DeliveryAddress {
  id           String  @id @default(uuid())
  userId       String
  user         User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  label        String?
  addressLine1 String
  addressLine2 String?
  city         String
  state        String?
  postalCode   String?
  country      String  @default("Nigeria")
  latitude     Float?
  longitude    Float?
  isDefault    Boolean @default(false)
  orders       Order[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  @@index([userId])
}

model Fee {
  id                 String               @id @default(uuid())
  type               FeeType
  amount             Float
  method             FeeCalculationMethod
  unit               String?
  minThreshold       Float?
  maxThreshold       Float?
  thresholdAppliesTo String?
  isActive           Boolean              @default(false)
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt

  @@unique([type, isActive])
}

model Category {
  id             String          @id @default(uuid())
  name           String          @unique
  imageUrl       String?
  description    String?
  parent         Category?       @relation("Subcategories", fields: [parentId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  parentId       String?
  children       Category[]      @relation("Subcategories")
  products       Product[]
  vendorProducts VendorProduct[]
  createdAt      DateTime?       @default(now())
  updatedAt      DateTime?       @updatedAt
}

model Tag {
  id             String          @id @default(uuid())
  name           String          @unique
  products       Product[]
  vendorProducts VendorProduct[]
}

model Vendor {
  id             String               @id @default(uuid())
  user           User                 @relation("Vendor", fields: [userId], references: [id], onDelete: Restrict)
  userId         String
  name           String
  email          String?
  tagline        String?
  details        String?
  image          String?
  address        String?
  longitude      Float?
  latitude       Float?
  timezone       String?              @default("America/New_York")
  isVerified     Boolean              @default(false)
  meta           Json?
  openingHours   VendorOpeningHours[]
  carts          Cart[]
  vendorProducts VendorProduct[]
  orders         Order[]
  staff          User[]               @relation("VendorStaff")
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt

  ratings Rating[]
}

model VendorOpeningHours {
  id        String   @id @default(uuid())
  vendor    Vendor   @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  vendorId  String
  day       Days
  open      String?
  close     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([vendorId, day])
}

model Support {
  id        String   @id @default(uuid())
  user      User?    @relation("SupportMessages", fields: [userId], references: [id])
  userId    String?
  name      String
  email     String
  message   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Setting {
  id        String   @id @default(uuid())
  key       String
  value     String
  type      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Rating {
  id        String      @id @default(uuid())
  orderId   String
  order     Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  raterId   String // The customer who is giving the rating
  rater     User        @relation("RatingsGiven", fields: [raterId], references: [id], onDelete: Cascade)

  // Who/what is being rated
  ratedVendorId String?
  ratedVendor   Vendor?     @relation(fields: [ratedVendorId], references: [id], onDelete: Cascade)
  ratedUserId   String? // If rating a shopper or deliverer
  ratedUser     User?       @relation("RatingsReceived", fields: [ratedUserId], references: [id], onDelete: Cascade)

  rating    Int // The score (e.g., 1-5)
  comment   String?
  type      RatingType
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orderId, type])
}

model WishlistItem {
  id              String        @id @default(uuid())
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  vendorProductId String
  vendorProduct   VendorProduct @relation(fields: [vendorProductId], references: [id], onDelete: Cascade)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // A user can only have a specific product in their wishlist once
  @@unique([userId, vendorProductId])
}

model Message {
  id          String   @id @default(uuid())
  content     String
  senderId    String
  sender      User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  recipientId String
  recipient   User     @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: Cascade)
  orderId     String
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  readAt      DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([orderId, createdAt])
}

enum Role {
  admin
  vendor
  vendor_staff
  delivery
  customer
  shopper
}

enum Days {
  monday
  tuesday
  wednesday
  thursday
  friday
  saturday
  sunday
}

enum PaymentMethods {
  credit_card
  wallet
  cash
}

enum PaymentStatus {
  pending
  paid
  failed
}

enum OrderStatus {
  pending
  accepted_for_shopping
  declined_by_vendor
  cancelled_by_customer
  currently_shopping
  ready_for_delivery
  ready_for_pickup
  en_route
  delivered
}

enum ShoppingMethod {
  vendor
  shopper
}

enum DeliveryMethod {
  delivery_person
  customer_pickup
}

enum FeeType {
  delivery
  service
  shopping
}

enum FeeCalculationMethod {
  flat
  percentage
  per_unit
  per_distance
}

enum RatingType {
  VENDOR
  SHOPPER
  DELIVERER
}

enum OrderItemStatus {
  PENDING
  FOUND
  NOT_FOUND
  REPLACED
}

enum NotificationType {
  // Order related for Customer
  ORDER_ACCEPTED
  ORDER_DECLINED
  ORDER_SHOPPING_STARTED
  ORDER_READY_FOR_PICKUP
  ORDER_READY_FOR_DELIVERY
  EN_ROUTE
  DELIVERED
  COMPLETED
  ORDER_CANCELLED

  // Order related for Vendor/Staff
  NEW_ORDER_PLACED

  // Order related for Shopper/Delivery Person
  ASSIGNED_TO_ORDER

  // General
  NEW_MESSAGE
  PROMOTIONAL
  ACCOUNT_UPDATE
}