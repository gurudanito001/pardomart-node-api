// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // or mysql, sqlite, etc. based on your actual database
  url      = env("DATABASE_URL")
}

model Verification {
  mobileNumber String    @id
  code         String
  expiresAt    DateTime
  createdAt    DateTime? @default(now())
  attempts     Int?      @default(0)
}

model User {
  id               String  @id @default(uuid())
  name             String
  email            String
  mobileNumber     String
  mobileVerified   Boolean @default(false)
  image            String?
  dynamicMediaUrls Json?
  active           Boolean @default(true)
  language         String?
  notification     Json?
  rememberToken    String?
  stripeCustomerId String?           @unique
  referralCode     String?
  role             Role
  // NEW: Link Vendor Staff to their Vendor
  vendorId         String? // ID of the Vendor this staff user belongs to (null for customers/delivery_persons)
  vendor           Vendor? @relation("VendorStaff", fields: [vendorId], references: [id], onDelete: SetNull)

  vendors           Vendor[]        @relation("Vendor")
  orderShoppers     Order[]           @relation("OrderShopper")
  orderDeliverers   Order[]           @relation("OrderDeliverer")
  deliveryAddresses DeliveryAddress[]
  orders            Order[]           @relation("OrderCustomer")
  carts             Cart[]
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // New fields for ratings
  ratingsGiven    Rating[] @relation("RatingsGiven")
  ratingsReceived Rating[] @relation("RatingsReceived")
  wishlistItems   WishlistItem[] 
  sentMessages    Message[]         @relation("SentMessages")
  receivedMessages  Message[]         @relation("ReceivedMessages")
  notifications   Notification[]
  supportTickets  SupportTicket[]
  savedPaymentMethods SavedPaymentMethod[]
  devices         Device[]
  transactions      Transaction[]
  bugReports      BugReport[]
  wallet          Wallet?

  @@unique([mobileNumber, role])
}

model Product {
  id              String          @id @default(uuid())
  barcode         String          @unique
  name            String
  description     String?
  images          String[]
  weight          Float?
  weightUnit      String?
  attributes      Json?
  meta            Json?
  vendorProducts  VendorProduct[] @relation("baseProduct")
  categoryIds     String[]
  categories      Category[]
  isAlcohol       Boolean         @default(false)
  isAgeRestricted Boolean         @default(false)
  tags            Tag[]
  isActive        Boolean         @default(true)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

model VendorProduct {
  id              String      @id @default(uuid())
  vendor          Vendor      @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  vendorId        String
  product         Product     @relation("baseProduct", fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  price           Float
  name            String
  description     String?
  discountedPrice Float?
  images          String[]
  weight          Float?
  weightUnit      String?
  stock           Int?
  isAvailable     Boolean     @default(true)
  isAlcohol       Boolean     @default(false)
  isAgeRestricted Boolean     @default(false)
  attributes      Json?
  categoryIds     String[]
  categories      Category[]
  tags            Tag[]
  cartItems       CartItem[]
  orderItems      OrderItem[] @relation("originalProduct")
  replacementFor  OrderItem[] @relation("replacementFor")
  wishlistItems   WishlistItem[]
  chosenAsReplacementFor OrderItem[] @relation("chosenReplacement")
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@unique([vendorId, productId])
}

model Cart {
  id        String     @id @default(uuid())
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  vendor    Vendor     @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  vendorId  String
  items     CartItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@unique([userId, vendorId]) // Ensure one cart per user-vendor pair
}

model CartItem {
  id              String        @id @default(uuid())
  cartId          String
  cart            Cart          @relation(fields: [cartId], references: [id], onDelete: Cascade)
  vendorProductId String
  vendorProduct   VendorProduct @relation(fields: [vendorProductId], references: [id])
  quantity        Int
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@unique([cartId, vendorProductId])
}

model OrderItem {
  id              String        @id @default(uuid())
  orderId         String
  order           Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  vendorProductId String
  vendorProduct   VendorProduct @relation("originalProduct", fields: [vendorProductId], references: [id])
  quantity        Int
  instructions    String?
  replacements    VendorProduct[] @relation("replacementFor")

  // Fields for live shopping
  status                OrderItemStatus @default(PENDING)
  quantityFound         Int?
  chosenReplacementId   String?
  chosenReplacement     VendorProduct?  @relation("chosenReplacement", fields: [chosenReplacementId], references: [id], onDelete: SetNull)
  isReplacementApproved Boolean?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

model DeliveryPersonLocation {
  id        String   @id @default(uuid())
  latitude  Float
  longitude Float
  createdAt DateTime @default(now())

  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, createdAt])
}

model Device {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  fcmToken  String   @unique // A token should be unique across all devices
  platform  String   // e.g., "ios", "android", "web"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Order {
  id                         String           @id @default(uuid())
  orderCode                  String           @unique
  userId                     String
  user                       User             @relation("OrderCustomer", fields: [userId], references: [id], onDelete: Cascade)
  vendorId                   String
  vendor                     Vendor           @relation(fields: [vendorId], references: [id])
  subtotal                   Float
  deliveryFee                Float?
  serviceFee                 Float?
  shoppingFee                Float?
  shopperTip                 Float? 
  deliveryPersonTip          Float?
  totalAmount                Float
  paymentMethod              PaymentMethods   @default(credit_card)
  paymentStatus              PaymentStatus    @default(pending)
  orderStatus                OrderStatus      @default(pending)
  reasonForDecline           String?
  deliveryAddressId          String?
  deliveryAddress            DeliveryAddress? @relation(fields: [deliveryAddressId], references: [id])
  deliveryInstructions       String?
  shopperId                  String?
  shopper                    User?            @relation("OrderShopper", fields: [shopperId], references: [id])
  deliveryPersonId           String?
  deliveryPerson             User?            @relation("OrderDeliverer", fields: [deliveryPersonId], references: [id])
  shoppingMethod             ShoppingMethod?  @default(vendor)
  deliveryMethod             DeliveryMethod?  @default(customer_pickup)
  shoppingStartTime          DateTime?
  scheduledDeliveryTime      DateTime?
  actualDeliveryTime         DateTime?
  orderItems                 OrderItem[]
  createdAt                  DateTime         @default(now())
  updatedAt                  DateTime         @updatedAt
  pickupOtp                  String?          // OTP for verifying pickup
  pickupOtpVerifiedAt        DateTime?        // Timestamp when OTP was verified
  ratings Rating[]
  deliveryPersonLocations DeliveryPersonLocation[]
  messages                   Message[]
  transactions            Transaction[]
}

model DeliveryAddress {
  id           String  @id @default(uuid())
  userId       String
  user         User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  label        String?
  addressLine1 String
  addressLine2 String?
  city         String
  state        String?
  postalCode   String?
  country      String  @default("Nigeria")
  latitude     Float?
  longitude    Float?
  isDefault    Boolean @default(false)
  orders       Order[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  @@index([userId])
}

model Fee {
  id                 String               @id @default(uuid())
  type               FeeType
  amount             Float
  method             FeeCalculationMethod
  unit               String?
  minThreshold       Float?
  maxThreshold       Float?
  thresholdAppliesTo String?
  isActive           Boolean              @default(true)
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt

  @@unique([type, isActive])
}

model Category {
  id             String          @id @default(uuid())
  name           String          @unique
  imageUrl       String?
  description    String?
  parent         Category?       @relation("Subcategories", fields: [parentId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  parentId       String?
  children       Category[]      @relation("Subcategories")
  products       Product[]
  vendorProducts VendorProduct[]
  createdAt      DateTime?       @default(now())
  updatedAt      DateTime?       @updatedAt
}

model Tag {
  id             String          @id @default(uuid())
  name           String          @unique
  products       Product[]
  vendorProducts VendorProduct[]
}

model Vendor {
  id             String               @id @default(uuid())
  user           User                 @relation("Vendor", fields: [userId], references: [id], onDelete: Restrict)
  userId         String
  name           String
  email          String?
  tagline        String?
  details        String?
  image          String?
  address        String?
  longitude      Float?
  latitude       Float?
  timezone       String?              @default("America/New_York")
  isVerified     Boolean              @default(false)
  isPublished    Boolean              @default(false)
  availableForShopping Boolean         @default(true)
  meta           Json?
  openingHours   VendorOpeningHours[]
  carts          Cart[]
  vendorProducts VendorProduct[]
  transactions    Transaction[]
  orders         Order[]
  staff          User[]               @relation("VendorStaff")
  ads            Ad[]
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  wallet         Wallet?

  ratings Rating[]
}

model VendorOpeningHours {
  id        String   @id @default(uuid())
  vendor    Vendor   @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  vendorId  String
  day       Days
  open      String?
  close     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([vendorId, day])
}

model SupportTicket {
  id          String         @id @default(uuid())
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  title       String
  imageUrl    String?
  description String
  category    TicketCategory
  status      TicketStatus   @default(OPEN)
  meta        Json? // e.g., { "orderId": "..." }
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([userId, status])
}

model Setting {
  id        String   @id @default(uuid())
  key       String
  value     String
  type      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Rating {
  id        String      @id @default(uuid())
  orderId   String
  order     Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  raterId   String // The customer who is giving the rating
  rater     User        @relation("RatingsGiven", fields: [raterId], references: [id], onDelete: Cascade)

  // Who/what is being rated
  ratedVendorId String?
  ratedVendor   Vendor?     @relation(fields: [ratedVendorId], references: [id], onDelete: Cascade)
  ratedUserId   String? // If rating a shopper or deliverer
  ratedUser     User?       @relation("RatingsReceived", fields: [ratedUserId], references: [id], onDelete: Cascade)

  rating    Int // The score (e.g., 1-5)
  comment   String?
  type      RatingType
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orderId, type])
}

model WishlistItem {
  id              String        @id @default(uuid())
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  vendorProductId String
  vendorProduct   VendorProduct @relation(fields: [vendorProductId], references: [id], onDelete: Cascade)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // A user can only have a specific product in their wishlist once
  @@unique([userId, vendorProductId])
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  category  NotificationCategory @default(ORDER)
  title     String
  body      String
  isRead    Boolean          @default(false)
  meta      Json? // To store related IDs like orderId, etc. for deep linking
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@index([userId, isRead, createdAt])
}

model Message {
  id          String   @id @default(uuid())
  content     String
  senderId    String
  sender      User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  recipientId String
  recipient   User     @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: Cascade)
  orderId     String
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  readAt      DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([orderId, createdAt])
}

model Wallet {
  id           String              @id @default(uuid())
  balance      Float               @default(0.0)
  transactions Transaction[]       // Transactions related to wallet top-ups and deductions
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt

  // A Wallet can belong to either a User or a Vendor, but not both.
  // The @unique constraint ensures a one-to-one relationship.
  userId       String?             @unique
  user         User?               @relation(fields: [userId], references: [id], onDelete: Cascade)
  vendorId     String?             @unique
  vendor       Vendor?             @relation(fields: [vendorId], references: [id], onDelete: Cascade)
}

model BugReport {
  id          String   @id @default(uuid())
  description String   @db.Text
  imageUrl    String?
  isResolved  Boolean  @default(false)

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Faq {
  id        String   @id @default(uuid())
  question  String
  answer    String   @db.Text
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Announcement {
  id             String    @id @default(uuid())
  title          String
  description    String    @db.Text
  imageUrl       String?
  targetAudience Role[]    // Uses PostgreSQL arrays to store multiple roles (e.g. [customer, vendor])
  isActive       Boolean   @default(true)
  sentAt         DateTime? // Null means draft; value means it has been broadcasted
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
}

model Content {
  id        String      @id @default(uuid())
  type      ContentType @unique
  content   String      @db.Text
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
}

enum ContentType {
  PRIVACY_POLICY
  TERMS_OF_SERVICE
}

model Media {
  id            String    @id @default(uuid())
  url           String
  type          MediaType
  mimeType      String
  size          Int? // File size in bytes
  name          String? // Original file name
  referenceId   String // ID of the related resource (e.g., user id, product id)
  referenceType ReferenceType? 
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([referenceId, referenceType])
}

model Ad {
  id          String    @id @default(uuid())
  title       String
  description String?
  imageUrl    String
  isActive    Boolean   @default(true)
  startDate   DateTime  @default(now())
  endDate     DateTime?

  vendorId    String
  vendor      Vendor    @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([vendorId])
}

model Transaction {
  id          String            @id @default(uuid())
  userId      String
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  walletId    String?
  wallet      Wallet?           @relation(fields: [walletId], references: [id], onDelete: SetNull)
  vendorId    String?           
  vendor      Vendor?           @relation(fields: [vendorId], references: [id], onDelete: SetNull)
  amount      Float // Can be positive (credit) or negative (debit)
  type        TransactionType
  source      TransactionSource
  status      TransactionStatus @default(COMPLETED)
  description String?

  // Optional fields for linking and external references
  orderId     String?
  order       Order?            @relation(fields: [orderId], references: [id], onDelete: SetNull)
  externalId  String? // For stripePaymentIntentId, etc.
  meta        Json? // For paymentMethodDetails, etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, orderId, type])
}

model SavedPaymentMethod {
  id                    String   @id @default(uuid())
  userId                String
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stripePaymentMethodId String   @unique
  cardBrand             String // e.g., "visa", "mastercard"
  cardLast4             String
  isDefault             Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([userId])
}

enum ReferenceType {
  bug_report_image
  ad_image
  user_image
  store_image
  product_image
  category_image
  document
  other
}

enum TransactionSource {
  STRIPE
  WALLET
  CASH
  BANK_TRANSFER
  SYSTEM // For adjustments, etc.
}

enum TransactionType {
  ORDER_PAYMENT
  WALLET_TOP_UP
  REFUND
  VENDOR_PAYOUT
  TIP_PAYOUT

  CREDIT
  DEBIT
}


enum Role {
  customer
  vendor
  store_admin
  store_shopper
  delivery_person
  admin
}

enum Days {
  monday
  tuesday
  wednesday
  thursday
  friday
  saturday
  sunday
}

enum PaymentMethods {
  credit_card
  wallet
  cash
}

enum PaymentStatus {
  pending
  paid
  failed
  refunded
}

enum OrderStatus {
  // Initial state
  pending // Order placed, awaiting vendor action.

  // Active Shopping Flow
  accepted_for_shopping
  currently_shopping

  // Handoff States (Shopping is complete)
  ready_for_pickup
  ready_for_delivery

  // Active Delivery Flow
  accepted_for_delivery
  en_route // Delivery person has the order and is on the way.

  // Terminal Success States
  delivered
  picked_up_by_customer // Order successfully picked up by the customer.

  // Terminal Failure/Cancellation States
  declined_by_vendor
  cancelled_by_customer
}

enum ShoppingMethod {
  vendor
  delivery_person
}

enum DeliveryMethod {
  delivery_person
  customer_pickup
}

enum FeeType {
  delivery
  service
  shopping
}

enum FeeCalculationMethod {
  flat
  percentage
  per_unit
  per_distance
}

enum RatingType {
  VENDOR
  SHOPPER
  DELIVERER
}

enum TicketCategory {
  BUG_REPORT
  FEATURE_REQUEST
  ORDER_ISSUE
  PAYMENT_ISSUE
  ACCOUNT_ISSUE
  OTHER
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

enum OrderItemStatus {
  PENDING
  FOUND
  NOT_FOUND
  REPLACED
}

enum NotificationType {
  // Order related for Customer
  ORDER_PLACED_CUSTOMER
  ORDER_ACCEPTED
  ORDER_DECLINED
  ORDER_SHOPPING_STARTED
  ORDER_READY_FOR_PICKUP
  ORDER_READY_FOR_DELIVERY
  EN_ROUTE
  DELIVERED
  COMPLETED
  ORDER_CANCELLED

  // Order related for Vendor/Staff
  NEW_ORDER_PLACED

  // Order related for Shopper/Delivery Person
  ASSIGNED_TO_ORDER

  // General
  NEW_MESSAGE
  PROMOTIONAL
  ACCOUNT_UPDATE

  // Add more as needed
  BUG_REPORT_RECEIVED
  BUG_REPORT_RESOLVED
  
}

enum NotificationCategory {
  ORDER
  SUPPORT
  SYSTEM
  PROMOTION
}

enum MediaType {
  IMAGE
  DOCUMENT
  VIDEO
  AUDIO
  OTHER
}